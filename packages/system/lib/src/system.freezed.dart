// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'system.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$DeviceTypeTearOff {
  const _$DeviceTypeTearOff();

// ignore: unused_element
  _PC1500 pc1500() {
    return const _PC1500();
  }

// ignore: unused_element
  PC2 pc2() {
    return const PC2();
  }

// ignore: unused_element
  _PC1500A pc1500A() {
    return const _PC1500A();
  }
}

// ignore: unused_element
const $DeviceType = _$DeviceTypeTearOff();

mixin _$DeviceType {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result pc1500(),
    @required Result pc2(),
    @required Result pc1500A(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result pc1500(),
    Result pc2(),
    Result pc1500A(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result pc1500(_PC1500 value),
    @required Result pc2(PC2 value),
    @required Result pc1500A(_PC1500A value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result pc1500(_PC1500 value),
    Result pc2(PC2 value),
    Result pc1500A(_PC1500A value),
    @required Result orElse(),
  });
}

abstract class $DeviceTypeCopyWith<$Res> {
  factory $DeviceTypeCopyWith(
          DeviceType value, $Res Function(DeviceType) then) =
      _$DeviceTypeCopyWithImpl<$Res>;
}

class _$DeviceTypeCopyWithImpl<$Res> implements $DeviceTypeCopyWith<$Res> {
  _$DeviceTypeCopyWithImpl(this._value, this._then);

  final DeviceType _value;
  // ignore: unused_field
  final $Res Function(DeviceType) _then;
}

abstract class _$PC1500CopyWith<$Res> {
  factory _$PC1500CopyWith(_PC1500 value, $Res Function(_PC1500) then) =
      __$PC1500CopyWithImpl<$Res>;
}

class __$PC1500CopyWithImpl<$Res> extends _$DeviceTypeCopyWithImpl<$Res>
    implements _$PC1500CopyWith<$Res> {
  __$PC1500CopyWithImpl(_PC1500 _value, $Res Function(_PC1500) _then)
      : super(_value, (v) => _then(v as _PC1500));

  @override
  _PC1500 get _value => super._value as _PC1500;
}

class _$_PC1500 implements _PC1500 {
  const _$_PC1500();

  @override
  String toString() {
    return 'DeviceType.pc1500()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PC1500);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result pc1500(),
    @required Result pc2(),
    @required Result pc1500A(),
  }) {
    assert(pc1500 != null);
    assert(pc2 != null);
    assert(pc1500A != null);
    return pc1500();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result pc1500(),
    Result pc2(),
    Result pc1500A(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (pc1500 != null) {
      return pc1500();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result pc1500(_PC1500 value),
    @required Result pc2(PC2 value),
    @required Result pc1500A(_PC1500A value),
  }) {
    assert(pc1500 != null);
    assert(pc2 != null);
    assert(pc1500A != null);
    return pc1500(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result pc1500(_PC1500 value),
    Result pc2(PC2 value),
    Result pc1500A(_PC1500A value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (pc1500 != null) {
      return pc1500(this);
    }
    return orElse();
  }
}

abstract class _PC1500 implements DeviceType {
  const factory _PC1500() = _$_PC1500;
}

abstract class $PC2CopyWith<$Res> {
  factory $PC2CopyWith(PC2 value, $Res Function(PC2) then) =
      _$PC2CopyWithImpl<$Res>;
}

class _$PC2CopyWithImpl<$Res> extends _$DeviceTypeCopyWithImpl<$Res>
    implements $PC2CopyWith<$Res> {
  _$PC2CopyWithImpl(PC2 _value, $Res Function(PC2) _then)
      : super(_value, (v) => _then(v as PC2));

  @override
  PC2 get _value => super._value as PC2;
}

class _$PC2 implements PC2 {
  const _$PC2();

  @override
  String toString() {
    return 'DeviceType.pc2()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PC2);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result pc1500(),
    @required Result pc2(),
    @required Result pc1500A(),
  }) {
    assert(pc1500 != null);
    assert(pc2 != null);
    assert(pc1500A != null);
    return pc2();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result pc1500(),
    Result pc2(),
    Result pc1500A(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (pc2 != null) {
      return pc2();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result pc1500(_PC1500 value),
    @required Result pc2(PC2 value),
    @required Result pc1500A(_PC1500A value),
  }) {
    assert(pc1500 != null);
    assert(pc2 != null);
    assert(pc1500A != null);
    return pc2(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result pc1500(_PC1500 value),
    Result pc2(PC2 value),
    Result pc1500A(_PC1500A value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (pc2 != null) {
      return pc2(this);
    }
    return orElse();
  }
}

abstract class PC2 implements DeviceType {
  const factory PC2() = _$PC2;
}

abstract class _$PC1500ACopyWith<$Res> {
  factory _$PC1500ACopyWith(_PC1500A value, $Res Function(_PC1500A) then) =
      __$PC1500ACopyWithImpl<$Res>;
}

class __$PC1500ACopyWithImpl<$Res> extends _$DeviceTypeCopyWithImpl<$Res>
    implements _$PC1500ACopyWith<$Res> {
  __$PC1500ACopyWithImpl(_PC1500A _value, $Res Function(_PC1500A) _then)
      : super(_value, (v) => _then(v as _PC1500A));

  @override
  _PC1500A get _value => super._value as _PC1500A;
}

class _$_PC1500A implements _PC1500A {
  const _$_PC1500A();

  @override
  String toString() {
    return 'DeviceType.pc1500A()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PC1500A);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result pc1500(),
    @required Result pc2(),
    @required Result pc1500A(),
  }) {
    assert(pc1500 != null);
    assert(pc2 != null);
    assert(pc1500A != null);
    return pc1500A();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result pc1500(),
    Result pc2(),
    Result pc1500A(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (pc1500A != null) {
      return pc1500A();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result pc1500(_PC1500 value),
    @required Result pc2(PC2 value),
    @required Result pc1500A(_PC1500A value),
  }) {
    assert(pc1500 != null);
    assert(pc2 != null);
    assert(pc1500A != null);
    return pc1500A(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result pc1500(_PC1500 value),
    Result pc2(PC2 value),
    Result pc1500A(_PC1500A value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (pc1500A != null) {
      return pc1500A(this);
    }
    return orElse();
  }
}

abstract class _PC1500A implements DeviceType {
  const factory _PC1500A() = _$_PC1500A;
}
