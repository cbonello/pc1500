// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'roms.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$ROMTypeTearOff {
  const _$ROMTypeTearOff();

// ignore: unused_element
  _A01 a01() {
    return const _A01();
  }

// ignore: unused_element
  _A03 a03() {
    return const _A03();
  }

// ignore: unused_element
  _A04 a04() {
    return const _A04();
  }
}

// ignore: unused_element
const $ROMType = _$ROMTypeTearOff();

mixin _$ROMType {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result a01(),
    @required Result a03(),
    @required Result a04(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result a01(),
    Result a03(),
    Result a04(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result a01(_A01 value),
    @required Result a03(_A03 value),
    @required Result a04(_A04 value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result a01(_A01 value),
    Result a03(_A03 value),
    Result a04(_A04 value),
    @required Result orElse(),
  });
}

abstract class $ROMTypeCopyWith<$Res> {
  factory $ROMTypeCopyWith(ROMType value, $Res Function(ROMType) then) =
      _$ROMTypeCopyWithImpl<$Res>;
}

class _$ROMTypeCopyWithImpl<$Res> implements $ROMTypeCopyWith<$Res> {
  _$ROMTypeCopyWithImpl(this._value, this._then);

  final ROMType _value;
  // ignore: unused_field
  final $Res Function(ROMType) _then;
}

abstract class _$A01CopyWith<$Res> {
  factory _$A01CopyWith(_A01 value, $Res Function(_A01) then) =
      __$A01CopyWithImpl<$Res>;
}

class __$A01CopyWithImpl<$Res> extends _$ROMTypeCopyWithImpl<$Res>
    implements _$A01CopyWith<$Res> {
  __$A01CopyWithImpl(_A01 _value, $Res Function(_A01) _then)
      : super(_value, (v) => _then(v as _A01));

  @override
  _A01 get _value => super._value as _A01;
}

class _$_A01 implements _A01 {
  const _$_A01();

  @override
  String toString() {
    return 'ROMType.a01()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _A01);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result a01(),
    @required Result a03(),
    @required Result a04(),
  }) {
    assert(a01 != null);
    assert(a03 != null);
    assert(a04 != null);
    return a01();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result a01(),
    Result a03(),
    Result a04(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (a01 != null) {
      return a01();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result a01(_A01 value),
    @required Result a03(_A03 value),
    @required Result a04(_A04 value),
  }) {
    assert(a01 != null);
    assert(a03 != null);
    assert(a04 != null);
    return a01(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result a01(_A01 value),
    Result a03(_A03 value),
    Result a04(_A04 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (a01 != null) {
      return a01(this);
    }
    return orElse();
  }
}

abstract class _A01 implements ROMType {
  const factory _A01() = _$_A01;
}

abstract class _$A03CopyWith<$Res> {
  factory _$A03CopyWith(_A03 value, $Res Function(_A03) then) =
      __$A03CopyWithImpl<$Res>;
}

class __$A03CopyWithImpl<$Res> extends _$ROMTypeCopyWithImpl<$Res>
    implements _$A03CopyWith<$Res> {
  __$A03CopyWithImpl(_A03 _value, $Res Function(_A03) _then)
      : super(_value, (v) => _then(v as _A03));

  @override
  _A03 get _value => super._value as _A03;
}

class _$_A03 implements _A03 {
  const _$_A03();

  @override
  String toString() {
    return 'ROMType.a03()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _A03);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result a01(),
    @required Result a03(),
    @required Result a04(),
  }) {
    assert(a01 != null);
    assert(a03 != null);
    assert(a04 != null);
    return a03();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result a01(),
    Result a03(),
    Result a04(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (a03 != null) {
      return a03();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result a01(_A01 value),
    @required Result a03(_A03 value),
    @required Result a04(_A04 value),
  }) {
    assert(a01 != null);
    assert(a03 != null);
    assert(a04 != null);
    return a03(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result a01(_A01 value),
    Result a03(_A03 value),
    Result a04(_A04 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (a03 != null) {
      return a03(this);
    }
    return orElse();
  }
}

abstract class _A03 implements ROMType {
  const factory _A03() = _$_A03;
}

abstract class _$A04CopyWith<$Res> {
  factory _$A04CopyWith(_A04 value, $Res Function(_A04) then) =
      __$A04CopyWithImpl<$Res>;
}

class __$A04CopyWithImpl<$Res> extends _$ROMTypeCopyWithImpl<$Res>
    implements _$A04CopyWith<$Res> {
  __$A04CopyWithImpl(_A04 _value, $Res Function(_A04) _then)
      : super(_value, (v) => _then(v as _A04));

  @override
  _A04 get _value => super._value as _A04;
}

class _$_A04 implements _A04 {
  const _$_A04();

  @override
  String toString() {
    return 'ROMType.a04()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _A04);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result a01(),
    @required Result a03(),
    @required Result a04(),
  }) {
    assert(a01 != null);
    assert(a03 != null);
    assert(a04 != null);
    return a04();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result a01(),
    Result a03(),
    Result a04(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (a04 != null) {
      return a04();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result a01(_A01 value),
    @required Result a03(_A03 value),
    @required Result a04(_A04 value),
  }) {
    assert(a01 != null);
    assert(a03 != null);
    assert(a04 != null);
    return a04(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result a01(_A01 value),
    Result a03(_A03 value),
    Result a04(_A04 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (a04 != null) {
      return a04(this);
    }
    return orElse();
  }
}

abstract class _A04 implements ROMType {
  const factory _A04() = _$_A04;
}
